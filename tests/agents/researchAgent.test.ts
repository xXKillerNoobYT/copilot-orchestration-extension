import { ResearchAgent } from '../../src/agents/researchAgent';
import * as llmService from '../../src/services/llmService';
import { logInfo, logError } from '../../src/logger';

// Mock dependencies
jest.mock('../../src/services/llmService');
jest.mock('../../src/logger');

const mockCompleteLLM = llmService.completeLLM as jest.MockedFunction<typeof llmService.completeLLM>;

describe('ResearchAgent', () => {
    beforeEach(() => {
        jest.clearAllMocks();
        jest.useRealTimers(); // Reset to real timers before each test
    });

    afterEach(() => {
        jest.useRealTimers(); // Clean up fake timers after each test
    });

    describe('runResearch()', () => {
        it('should generate a markdown report with query, timestamp, and content', async () => {
            // Arrange
            jest.useFakeTimers();
            const agent = new ResearchAgent();
            const query = 'What is TypeScript?';
            const llmResponse = `## Summary
TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.

## Key Findings
- Adds static typing to JavaScript
- Developed by Microsoft
- Improves code quality and maintainability
- Compatible with existing JavaScript code

## Detailed Analysis
TypeScript provides optional static typing, classes, and interfaces. This helps catch errors during development rather than at runtime.`;

            mockCompleteLLM.mockResolvedValue({
                content: llmResponse,
                usage: { prompt_tokens: 10, completion_tokens: 50, total_tokens: 60 }
            });

            // Act
            const promise = agent.runResearch(query);
            
            // Fast-forward time by 10 minutes
            await jest.advanceTimersByTimeAsync(600000);
            
            const report = await promise;

            // Assert
            expect(report).toContain('# Research Report: What is TypeScript?');
            expect(report).toContain('**Generated:**');
            expect(report).toContain(llmResponse);
            expect(report).toContain('*Generated by COE Research Agent*');
            expect(mockCompleteLLM).toHaveBeenCalledTimes(1);
            expect(logInfo).toHaveBeenCalledWith(
                expect.stringContaining('[ResearchAgent] Starting research')
            );
        });

        it('should call completeLLM with correct system prompt and temperature', async () => {
            // Arrange
            jest.useFakeTimers();
            const agent = new ResearchAgent();
            const query = 'Explain async/await in JavaScript';

            mockCompleteLLM.mockResolvedValue({
                content: 'Research content here',
                usage: { prompt_tokens: 5, completion_tokens: 20, total_tokens: 25 }
            });

            // Act
            const promise = agent.runResearch(query);
            await jest.advanceTimersByTimeAsync(600000);
            await promise;

            // Assert
            expect(mockCompleteLLM).toHaveBeenCalledWith(
                query,
                expect.objectContaining({
                    systemPrompt: expect.stringContaining('research assistant'),
                    temperature: 0.7
                })
            );
        });

        it('should simulate 10-minute delay before calling LLM', async () => {
            // Arrange
            jest.useFakeTimers();
            const agent = new ResearchAgent();
            const query = 'Test query';

            mockCompleteLLM.mockResolvedValue({
                content: 'Test response',
                usage: { prompt_tokens: 1, completion_tokens: 1, total_tokens: 2 }
            });

            // Act
            const promise = agent.runResearch(query);

            // Assert - LLM should not be called immediately
            expect(mockCompleteLLM).not.toHaveBeenCalled();

            // Advance time by 9 minutes - still not called
            await jest.advanceTimersByTimeAsync(540000);
            expect(mockCompleteLLM).not.toHaveBeenCalled();

            // Advance remaining 1 minute - now it should be called
            await jest.advanceTimersByTimeAsync(60000);
            await promise;

            expect(mockCompleteLLM).toHaveBeenCalledTimes(1);
        });

        it('should handle LLM errors gracefully and return error MD report', async () => {
            // Arrange
            jest.useFakeTimers();
            const agent = new ResearchAgent();
            const query = 'Test query with error';
            const errorMessage = 'LLM service unavailable';

            mockCompleteLLM.mockRejectedValue(new Error(errorMessage));

            // Act
            const promise = agent.runResearch(query);
            await jest.advanceTimersByTimeAsync(600000);
            const report = await promise;

            // Assert
            expect(report).toContain('# Research Error');
            expect(report).toContain(`**Query:** ${query}`);
            expect(report).toContain(errorMessage);
            expect(report).toContain('Failed to generate research report');
            expect(logError).toHaveBeenCalledWith(
                expect.stringContaining(`[ResearchAgent] Research failed: ${errorMessage}`)
            );
        });

        it('should handle non-Error thrown values', async () => {
            // Arrange
            jest.useFakeTimers();
            const agent = new ResearchAgent();
            const query = 'Test query';

            mockCompleteLLM.mockRejectedValue('String error');

            // Act
            const promise = agent.runResearch(query);
            await jest.advanceTimersByTimeAsync(600000);
            const report = await promise;

            // Assert
            expect(report).toContain('# Research Error');
            expect(report).toContain('String error');
            expect(logError).toHaveBeenCalledWith(
                expect.stringContaining('[ResearchAgent] Research failed: String error')
            );
        });

        it('should truncate long queries in logs to prevent overflow', async () => {
            // Arrange
            jest.useFakeTimers();
            const agent = new ResearchAgent();
            const longQuery = 'A'.repeat(150); // 150 characters

            mockCompleteLLM.mockResolvedValue({
                content: 'Response',
                usage: { prompt_tokens: 1, completion_tokens: 1, total_tokens: 2 }
            });

            // Act
            const promise = agent.runResearch(longQuery);
            await jest.advanceTimersByTimeAsync(600000);
            await promise;

            // Assert
            expect(logInfo).toHaveBeenCalledWith(
                expect.stringMatching(/\[ResearchAgent\] Starting research for query: "A{100}\.\.\."/
            ));
        });

        it('should log completion with content length', async () => {
            // Arrange
            jest.useFakeTimers();
            const agent = new ResearchAgent();
            const query = 'Test';
            const responseContent = 'A'.repeat(500);

            mockCompleteLLM.mockResolvedValue({
                content: responseContent,
                usage: { prompt_tokens: 1, completion_tokens: 1, total_tokens: 2 }
            });

            // Act
            const promise = agent.runResearch(query);
            await jest.advanceTimersByTimeAsync(600000);
            await promise;

            // Assert
            expect(logInfo).toHaveBeenCalledWith(
                expect.stringContaining('[ResearchAgent] Research complete. Generated 500 characters.')
            );
        });

        it('should include helpful troubleshooting tips in error reports', async () => {
            // Arrange
            jest.useFakeTimers();
            const agent = new ResearchAgent();
            const query = 'Test';

            mockCompleteLLM.mockRejectedValue(new Error('Connection timeout'));

            // Act
            const promise = agent.runResearch(query);
            await jest.advanceTimersByTimeAsync(600000);
            const report = await promise;

            // Assert
            expect(report).toContain('LLM service unavailability');
            expect(report).toContain('Network connectivity issues');
            expect(report).toContain('Query processing errors');
            expect(report).toContain('Please try again later');
        });
    });
});
